{"ts":1364669703755,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*!\n * Jade\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Parser = require('./parser')\n  , Lexer = require('./lexer')\n  , Compiler = require('./compiler')\n  , runtime = require('./runtime')\n// if node\n  , fs = require('fs');\n// end\n\n/**\n * Library version.\n */\n\nexports.version = '0.28.2';\n\n/**\n * Expose self closing tags.\n */\n\nexports.selfClosing = require('./self-closing');\n\n/**\n * Default supported doctypes.\n */\n\nexports.doctypes = require('./doctypes');\n\n/**\n * Text filters.\n */\n\nexports.filters = require('./filters');\n\n/**\n * Utilities.\n */\n\nexports.utils = require('./utils');\n\n/**\n * Expose `Compiler`.\n */\n\nexports.Compiler = Compiler;\n\n/**\n * Expose `Parser`.\n */\n\nexports.Parser = Parser;\n\n/**\n * Expose `Lexer`.\n */\n\nexports.Lexer = Lexer;\n\n/**\n * Nodes.\n */\n\nexports.nodes = require('./nodes');\n\n/**\n * Jade runtime helpers.\n */\n\nexports.runtime = runtime;\n\n/**\n * Template function cache.\n */\n\nexports.cache = {};\n\n/**\n * Parse the given `str` of jade and return a function body.\n *\n * @param {String} str\n * @param {Object} options\n * @return {String}\n * @api private\n */\n\nfunction parse(str, options){\n  try {\n    // Parse\n    var parser = new Parser(str, options.filename, options);\n\n    // Compile\n    var compiler = new (options.compiler || Compiler)(parser.parse(), options)\n      , js = compiler.compile();\n\n    // Debug compiler\n    if (options.debug) {\n      console.error('\\nCompiled Function:\\n\\n\\033[90m%s\\033[0m', js.replace(/^/gm, '  '));\n    }\n\n    return ''\n      + 'var buf = [];\\n'\n      + (options.self\n        ? 'var self = locals || {};\\n' + js\n        : 'with (locals || {}) {\\n' + js + '\\n}\\n')\n      + 'return buf.join(\"\");';\n  } catch (err) {\n    parser = parser.context();\n    runtime.rethrow(err, parser.filename, parser.lexer.lineno);\n  }\n}\n\n/**\n * Strip any UTF-8 BOM off of the start of `str`, if it exists.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nfunction stripBOM(str){\n  return 0xFEFF == str.charCodeAt(0)\n    ? str.substring(1)\n    : str;\n}\n\n/**\n * Compile a `Function` representation of the given jade `str`.\n *\n * Options:\n *\n *   - `compileDebug` when `false` debugging code is stripped from the compiled template\n *   - `client` when `true` the helper functions `escape()` etc will reference `jade.escape()`\n *      for use with the Jade client-side runtime.js\n *\n * @param {String} str\n * @param {Options} options\n * @return {Function}\n * @api public\n */\n\nexports.compile = function(str, options){\n  var options = options || {}\n    , client = options.client\n    , filename = options.filename\n      ? JSON.stringify(options.filename)\n      : 'undefined'\n    , fn;\n\n  str = stripBOM(String(str));\n\n  if (options.compileDebug !== false) {\n    fn = [\n        'var __jade = [{ lineno: 1, filename: ' + filename + ' }];'\n      , 'try {'\n      , parse(str, options)\n      , '} catch (err) {'\n      , '  rethrow(err, __jade[0].filename, __jade[0].lineno);'\n      , '}'\n    ].join('\\n');\n  } else {\n    fn = parse(str, options);\n  }\n\n  if (client) {\n    fn = 'attrs = attrs || jade.attrs; escape = escape || jade.escape; rethrow = rethrow || jade.rethrow; merge = merge || jade.merge;\\n' + fn;\n  }\n\n  fn = new Function('locals, attrs, escape, rethrow, merge', fn);\n\n  if (client) return fn;\n\n  return function(locals){\n    return fn(locals, runtime.attrs, runtime.escape, runtime.rethrow, runtime.merge);\n  };\n};\n\n/**\n * Render the given `str` of jade and invoke\n * the callback `fn(err, str)`.\n *\n * Options:\n *\n *   - `cache` enable template caching\n *   - `filename` filename required for `include` / `extends` and caching\n *\n * @param {String} str\n * @param {Object|Function} options or fn\n * @param {Function} fn\n * @api public\n */\n\nexports.render = function(str, options, fn){\n  // swap args\n  if ('function' == typeof options) {\n    fn = options, options = {};\n  }\n\n  // cache requires .filename\n  if (options.cache && !options.filename) {\n    return fn(new Error('the \"filename\" option is required for caching'));\n  }\n\n  try {\n    var path = options.filename;\n    var tmpl = options.cache\n      ? exports.cache[path] || (exports.cache[path] = exports.compile(str, options))\n      : exports.compile(str, options);\n    fn(null, tmpl(options));\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Render a Jade file at the given `path` and callback `fn(err, str)`.\n *\n * @param {String} path\n * @param {Object|Function} options or callback\n * @param {Function} fn\n * @api public\n */\n\nexports.renderFile = function(path, options, fn){\n  var key = path + ':string';\n\n  if ('function' == typeof options) {\n    fn = options, options = {};\n  }\n\n  try {\n    options.filename = path;\n    var str = options.cache\n      ? exports.cache[key] || (exports.cache[key] = fs.readFileSync(path, 'utf8'))\n      : fs.readFileSync(path, 'utf8');\n    exports.render(str, options, fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Express support.\n */\n\nexports.__express = exports.renderFile;\n"]],"start1":0,"start2":0,"length1":0,"length2":5016}]],"length":5016}
