{"ts":1364669774849,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * Module dependencies.\n */\n\nvar http = require('http')\n  , path = require('path')\n  , connect = require('connect')\n  , utils = connect.utils\n  , sign = require('cookie-signature').sign\n  , normalizeType = require('./utils').normalizeType\n  , normalizeTypes = require('./utils').normalizeTypes\n  , etag = require('./utils').etag\n  , statusCodes = http.STATUS_CODES\n  , cookie = require('cookie')\n  , send = require('send')\n  , mime = connect.mime\n  , basename = path.basename\n  , extname = path.extname\n  , join = path.join;\n\n/**\n * Response prototype.\n */\n\nvar res = module.exports = {\n  __proto__: http.ServerResponse.prototype\n};\n\n/**\n * Set status `code`.\n *\n * @param {Number} code\n * @return {ServerResponse}\n * @api public\n */\n\nres.status = function(code){\n  this.statusCode = code;\n  return this;\n};\n\n/**\n * Set Link header field with the given `links`.\n *\n * Examples:\n *\n *    res.links({\n *      next: 'http://api.example.com/users?page=2',\n *      last: 'http://api.example.com/users?page=5'\n *    });\n *\n * @param {Object} links\n * @return {ServerResponse}\n * @api public\n */\n\nres.links = function(links){\n  return this.set('Link', Object.keys(links).map(function(rel){\n    return '<' + links[rel] + '>; rel=\"' + rel + '\"';\n  }).join(', '));\n};\n\n/**\n * Send a response.\n *\n * Examples:\n *\n *     res.send(new Buffer('wahoo'));\n *     res.send({ some: 'json' });\n *     res.send('<p>some html</p>');\n *     res.send(404, 'Sorry, cant find that');\n *     res.send(404);\n *\n * @param {Mixed} body or status\n * @param {Mixed} body\n * @return {ServerResponse}\n * @api public\n */\n\nres.send = function(body){\n  var req = this.req\n    , head = 'HEAD' == req.method\n    , len;\n\n  // allow status / body\n  if (2 == arguments.length) {\n    // res.send(body, status) backwards compat\n    if ('number' != typeof body && 'number' == typeof arguments[1]) {\n      this.statusCode = arguments[1];\n    } else {\n      this.statusCode = body;\n      body = arguments[1];\n    }\n  }\n\n  switch (typeof body) {\n    // response status\n    case 'number':\n      this.get('Content-Type') || this.type('txt');\n      this.statusCode = body;\n      body = http.STATUS_CODES[body];\n      break;\n    // string defaulting to html\n    case 'string':\n      if (!this.get('Content-Type')) {\n        this.charset = this.charset || 'utf-8';\n        this.type('html');\n      }\n      break;\n    case 'boolean':\n    case 'object':\n      if (null == body) {\n        body = '';\n      } else if (Buffer.isBuffer(body)) {\n        this.get('Content-Type') || this.type('bin');\n      } else {\n        return this.json(body);\n      }\n      break;\n  }\n\n  // populate Content-Length\n  if (undefined !== body && !this.get('Content-Length')) {\n    this.set('Content-Length', len = Buffer.isBuffer(body)\n      ? body.length\n      : Buffer.byteLength(body));\n  }\n\n  // ETag support\n  // TODO: W/ support\n  if (len > 1024) {\n    if (!this.get('ETag')) {\n      this.set('ETag', etag(body));\n    }\n  }\n\n  // freshness\n  if (req.fresh) this.statusCode = 304;\n\n  // strip irrelevant headers\n  if (204 == this.statusCode || 304 == this.statusCode) {\n    this.removeHeader('Content-Type');\n    this.removeHeader('Content-Length');\n    this.removeHeader('Transfer-Encoding');\n    body = '';\n  }\n\n  // respond\n  this.end(head ? null : body);\n  return this;\n};\n\n/**\n * Send JSON response.\n *\n * Examples:\n *\n *     res.json(null);\n *     res.json({ user: 'tj' });\n *     res.json(500, 'oh noes!');\n *     res.json(404, 'I dont have that');\n *\n * @param {Mixed} obj or status\n * @param {Mixed} obj\n * @return {ServerResponse}\n * @api public\n */\n\nres.json = function(obj){\n  // allow status / body\n  if (2 == arguments.length) {\n    // res.json(body, status) backwards compat\n    if ('number' == typeof arguments[1]) {\n      this.statusCode = arguments[1];\n    } else {\n      this.statusCode = obj;\n      obj = arguments[1];\n    }\n  }\n\n  // settings\n  var app = this.app;\n  var replacer = app.get('json replacer');\n  var spaces = app.get('json spaces');\n  var body = JSON.stringify(obj, replacer, spaces);\n\n  // content-type\n  this.charset = this.charset || 'utf-8';\n  this.get('Content-Type') || this.set('Content-Type', 'application/json');\n\n  return this.send(body);\n};\n\n/**\n * Send JSON response with JSONP callback support.\n *\n * Examples:\n *\n *     res.jsonp(null);\n *     res.jsonp({ user: 'tj' });\n *     res.jsonp(500, 'oh noes!');\n *     res.jsonp(404, 'I dont have that');\n *\n * @param {Mixed} obj or status\n * @param {Mixed} obj\n * @return {ServerResponse}\n * @api public\n */\n\nres.jsonp = function(obj){\n  // allow status / body\n  if (2 == arguments.length) {\n    // res.json(body, status) backwards compat\n    if ('number' == typeof arguments[1]) {\n      this.statusCode = arguments[1];\n    } else {\n      this.statusCode = obj;\n      obj = arguments[1];\n    }\n  }\n\n  // settings\n  var app = this.app;\n  var replacer = app.get('json replacer');\n  var spaces = app.get('json spaces');\n  var body = JSON.stringify(obj, replacer, spaces)\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029');\n  var callback = this.req.query[app.get('jsonp callback name')];\n\n  // content-type\n  this.charset = this.charset || 'utf-8';\n  this.set('Content-Type', 'application/json');\n\n  // jsonp\n  if (callback) {\n    this.set('Content-Type', 'text/javascript');\n    var cb = callback.replace(/[^\\[\\]\\w$.]/g, '');\n    body = cb + ' && ' + cb + '(' + body + ');';\n  }\n\n  return this.send(body);\n};\n\n/**\n * Transfer the file at the given `path`.\n *\n * Automatically sets the _Content-Type_ response header field.\n * The callback `fn(err)` is invoked when the transfer is complete\n * or when an error occurs. Be sure to check `res.sentHeader`\n * if you wish to attempt responding, as the header and some data\n * may have already been transferred.\n *\n * Options:\n *\n *   - `maxAge` defaulting to 0\n *   - `root`   root directory for relative filenames\n *\n * Examples:\n *\n *  The following example illustrates how `res.sendfile()` may\n *  be used as an alternative for the `static()` middleware for\n *  dynamic situations. The code backing `res.sendfile()` is actually\n *  the same code, so HTTP cache support etc is identical.\n *\n *     app.get('/user/:uid/photos/:file', function(req, res){\n *       var uid = req.params.uid\n *         , file = req.params.file;\n *\n *       req.user.mayViewFilesFrom(uid, function(yes){\n *         if (yes) {\n *           res.sendfile('/uploads/' + uid + '/' + file);\n *         } else {\n *           res.send(403, 'Sorry! you cant see that.');\n *         }\n *       });\n *     });\n *\n * @param {String} path\n * @param {Object|Function} options or fn\n * @param {Function} fn\n * @api public\n */\n\nres.sendfile = function(path, options, fn){\n  var self = this\n    , req = self.req\n    , next = this.req.next\n    , options = options || {}\n    , done;\n\n  // support function as second arg\n  if ('function' == typeof options) {\n    fn = options;\n    options = {};\n  }\n\n  // socket errors\n  req.socket.on('error', error);\n\n  // errors\n  function error(err) {\n    if (done) return;\n    done = true;\n\n    // clean up\n    cleanup();\n    if (!self.headerSent) self.removeHeader('Content-Disposition');\n\n    // callback available\n    if (fn) return fn(err);\n\n    // list in limbo if there's no callback\n    if (self.headerSent) return;\n\n    // delegate\n    next(err);\n  }\n\n  // streaming\n  function stream() {\n    if (done) return;\n    cleanup();\n    if (fn) self.on('finish', fn);\n  }\n\n  // cleanup\n  function cleanup() {\n    req.socket.removeListener('error', error);\n  }\n\n  // transfer\n  var file = send(req, path);\n  if (options.root) file.root(options.root);\n  file.maxage(options.maxAge || 0);\n  file.on('error', error);\n  file.on('directory', next);\n  file.on('stream', stream);\n  file.pipe(this);\n  this.on('finish', cleanup);\n};\n\n/**\n * Transfer the file at the given `path` as an attachment.\n *\n * Optionally providing an alternate attachment `filename`,\n * and optional callback `fn(err)`. The callback is invoked\n * when the data transfer is complete, or when an error has\n * ocurred. Be sure to check `res.headerSent` if you plan to respond.\n *\n * This method uses `res.sendfile()`.\n *\n * @param {String} path\n * @param {String|Function} filename or fn\n * @param {Function} fn\n * @api public\n */\n\nres.download = function(path, filename, fn){\n  // support function as second arg\n  if ('function' == typeof filename) {\n    fn = filename;\n    filename = null;\n  }\n\n  filename = filename || path;\n  this.set('Content-Disposition', 'attachment; filename=\"' + basename(filename) + '\"');\n  return this.sendfile(path, fn);\n};\n\n/**\n * Set _Content-Type_ response header with `type` through `mime.lookup()`\n * when it does not contain \"/\", or set the Content-Type to `type` otherwise.\n *\n * Examples:\n *\n *     res.type('.html');\n *     res.type('html');\n *     res.type('json');\n *     res.type('application/json');\n *     res.type('png');\n *\n * @param {String} type\n * @return {ServerResponse} for chaining\n * @api public\n */\n\nres.contentType =\nres.type = function(type){\n  return this.set('Content-Type', ~type.indexOf('/')\n    ? type\n    : mime.lookup(type));\n};\n\n/**\n * Respond to the Acceptable formats using an `obj`\n * of mime-type callbacks.\n *\n * This method uses `req.accepted`, an array of\n * acceptable types ordered by their quality values.\n * When \"Accept\" is not present the _first_ callback\n * is invoked, otherwise the first match is used. When\n * no match is performed the server responds with\n * 406 \"Not Acceptable\".\n *\n * Content-Type is set for you, however if you choose\n * you may alter this within the callback using `res.type()`\n * or `res.set('Content-Type', ...)`.\n *\n *    res.format({\n *      'text/plain': function(){\n *        res.send('hey');\n *      },\n *\n *      'text/html': function(){\n *        res.send('<p>hey</p>');\n *      },\n *\n *      'appliation/json': function(){\n *        res.send({ message: 'hey' });\n *      }\n *    });\n *\n * In addition to canonicalized MIME types you may\n * also use extnames mapped to these types:\n *\n *    res.format({\n *      text: function(){\n *        res.send('hey');\n *      },\n *\n *      html: function(){\n *        res.send('<p>hey</p>');\n *      },\n *\n *      json: function(){\n *        res.send({ message: 'hey' });\n *      }\n *    });\n *\n * By default Express passes an `Error`\n * with a `.status` of 406 to `next(err)`\n * if a match is not made. If you provide\n * a `.default` callback it will be invoked\n * instead.\n *\n * @param {Object} obj\n * @return {ServerResponse} for chaining\n * @api public\n */\n\nres.format = function(obj){\n  var req = this.req\n    , next = req.next;\n\n  var fn = obj.default;\n  if (fn) delete obj.default;\n  var keys = Object.keys(obj);\n\n  var key = req.accepts(keys);\n\n  this.set('Vary', 'Accept');\n\n  if (key) {\n    this.set('Content-Type', normalizeType(key));\n    obj[key](req, this, next);\n  } else if (fn) {\n    fn();\n  } else {\n    var err = new Error('Not Acceptable');\n    err.status = 406;\n    err.types = normalizeTypes(keys);\n    next(err);\n  }\n\n  return this;\n};\n\n/**\n * Set _Content-Disposition_ header to _attachment_ with optional `filename`.\n *\n * @param {String} filename\n * @return {ServerResponse}\n * @api public\n */\n\nres.attachment = function(filename){\n  if (filename) this.type(extname(filename));\n  this.set('Content-Disposition', filename\n    ? 'attachment; filename=\"' + basename(filename) + '\"'\n    : 'attachment');\n  return this;\n};\n\n/**\n * Set header `field` to `val`, or pass\n * an object of header fields.\n *\n * Examples:\n *\n *    res.set('Foo', ['bar', 'baz']);\n *    res.set('Accept', 'application/json');\n *    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });\n *\n * Aliased as `res.header()`.\n *\n * @param {String|Object|Array} field\n * @param {String} val\n * @return {ServerResponse} for chaining\n * @api public\n */\n\nres.set =\nres.header = function(field, val){\n  if (2 == arguments.length) {\n    if (Array.isArray(val)) val = val.map(String);\n    else val = String(val);\n    this.setHeader(field, val);\n  } else {\n    for (var key in field) {\n      this.set(key, field[key]);\n    }\n  }\n  return this;\n};\n\n/**\n * Get value for header `field`.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nres.get = function(field){\n  return this.getHeader(field);\n};\n\n/**\n * Clear cookie `name`.\n *\n * @param {String} name\n * @param {Object} options\n * @param {ServerResponse} for chaining\n * @api public\n */\n\nres.clearCookie = function(name, options){\n  var opts = { expires: new Date(1), path: '/' };\n  return this.cookie(name, '', options\n    ? utils.merge(opts, options)\n    : opts);\n};\n\n/**\n * Set cookie `name` to `val`, with the given `options`.\n *\n * Options:\n *\n *    - `maxAge`   max-age in milliseconds, converted to `expires`\n *    - `signed`   sign the cookie\n *    - `path`     defaults to \"/\"\n *\n * Examples:\n *\n *    // \"Remember Me\" for 15 minutes\n *    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });\n *\n *    // save as above\n *    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })\n *\n * @param {String} name\n * @param {String|Object} val\n * @param {Options} options\n * @api public\n */\n\nres.cookie = function(name, val, options){\n  options = utils.merge({}, options);\n  var secret = this.req.secret;\n  var signed = options.signed;\n  if (signed && !secret) throw new Error('connect.cookieParser(\"secret\") required for signed cookies');\n  if ('object' == typeof val) val = 'j:' + JSON.stringify(val);\n  if (signed) val = 's:' + sign(val, secret);\n  if ('maxAge' in options) {\n    options.expires = new Date(Date.now() + options.maxAge);\n    options.maxAge /= 1000;\n  }\n  if (null == options.path) options.path = '/';\n  this.set('Set-Cookie', cookie.serialize(name, String(val), options));\n  return this;\n};\n\n\n/**\n * Set the location header to `url`.\n *\n * The given `url` can also be the name of a mapped url, for\n * example by default express supports \"back\" which redirects\n * to the _Referrer_ or _Referer_ headers or \"/\".\n *\n * Examples:\n *\n *    res.location('/foo/bar').;\n *    res.location('http://example.com');\n *    res.location('../login'); // /blog/post/1 -> /blog/login\n *\n * Mounting:\n *\n *   When an application is mounted and `res.location()`\n *   is given a path that does _not_ lead with \"/\" it becomes\n *   relative to the mount-point. For example if the application\n *   is mounted at \"/blog\", the following would become \"/blog/login\".\n *\n *      res.location('login');\n *\n *   While the leading slash would result in a location of \"/login\":\n *\n *      res.location('/login');\n *\n * @param {String} url\n * @api public\n */\n\nres.location = function(url){\n  var app = this.app\n    , req = this.req;\n\n  // setup redirect map\n  var map = { back: req.get('Referrer') || '/' };\n\n  // perform redirect\n  url = map[url] || url;\n\n  // relative\n  if (!~url.indexOf('://') && 0 != url.indexOf('//')) {\n    var path = app.path();\n\n    // relative to path\n    if ('.' == url[0]) {\n      url = req.path + '/' + url;\n    // relative to mount-point\n    } else if ('/' != url[0]) {\n      url = path + '/' + url;\n    }\n  }\n\n  // Respond\n  this.set('Location', url);\n  return this;\n};\n\n/**\n * Redirect to the given `url` with optional response `status`\n * defaulting to 302.\n *\n * The resulting `url` is determined by `res.location()`, so\n * it will play nicely with mounted apps, relative paths,\n * `\"back\"` etc.\n *\n * Examples:\n *\n *    res.redirect('/foo/bar');\n *    res.redirect('http://example.com');\n *    res.redirect(301, 'http://example.com');\n *    res.redirect('http://example.com', 301);\n *    res.redirect('../login'); // /blog/post/1 -> /blog/login\n *\n * @param {String} url\n * @param {Number} code\n * @api public\n */\n\nres.redirect = function(url){\n  var app = this.app\n    , head = 'HEAD' == this.req.method\n    , status = 302\n    , body;\n\n  // allow status / url\n  if (2 == arguments.length) {\n    if ('number' == typeof url) {\n      status = url;\n      url = arguments[1];\n    } else {\n      status = arguments[1];\n    }\n  }\n\n  // Set location header\n  this.location(url);\n  url = this.get('Location');\n\n  // Support text/{plain,html} by default\n  this.format({\n    text: function(){\n      body = statusCodes[status] + '. Redirecting to ' + encodeURI(url);\n    },\n\n    html: function(){\n      var u = utils.escape(url);\n      body = '<p>' + statusCodes[status] + '. Redirecting to <a href=\"' + u + '\">' + u + '</a></p>';\n    },\n\n    default: function(){\n      body = '';\n    }\n  });\n\n  // Respond\n  this.statusCode = status;\n  this.set('Content-Length', Buffer.byteLength(body));\n  this.end(head ? null : body);\n};\n\n/**\n * Render `view` with the given `options` and optional callback `fn`.\n * When a callback function is given a response will _not_ be made\n * automatically, otherwise a response of _200_ and _text/html_ is given.\n *\n * Options:\n *\n *  - `cache`     boolean hinting to the engine it should cache\n *  - `filename`  filename of the view being rendered\n *\n * @param  {String} view\n * @param  {Object|Function} options or callback function\n * @param  {Function} fn\n * @api public\n */\n\nres.render = function(view, options, fn){\n  var self = this\n    , options = options || {}\n    , req = this.req\n    , app = req.app;\n\n  // support callback function as second arg\n  if ('function' == typeof options) {\n    fn = options, options = {};\n  }\n\n  // merge res.locals\n  options._locals = self.locals;\n\n  // default callback to respond\n  fn = fn || function(err, str){\n    if (err) return req.next(err);\n    self.send(str);\n  };\n\n  // render\n  app.render(view, options, fn);\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":17611}]],"length":17611}
